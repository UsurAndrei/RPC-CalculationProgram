/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calcprog.h"
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <netdb.h>
#include <string.h>
#include <unistd.h>

#define SERVER_PORT 6060

void calc_prog_1(char *host)
{
	CLIENT *clnt;
	double  *result_1;
	clientData1  calcavg_1_arg;
	returnData2  *result_2;
	clientData2  calcmaxmin_1_arg;
	returnData3  *result_3;
	clientData3  calcmult_1_arg;

	int lsd, sd;
    struct sockaddr_in sin;
    int sin_size = sizeof(sin);
    char buffer[150];
    int calcNum = 1, N, i;
    double a, resultArray[100];
    int array[100];

#ifndef	DEBUG
	clnt = clnt_create (host, CALC_PROG, CALC_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */
	// Create listening socket
	lsd = socket(AF_INET, SOCK_STREAM, 0);
    if(lsd == -1)
    {
        printf("Cannot create listening socket, program will exit!\n");
        exit(1);  
    }
	// Initialize struct sockaddr_in in values
    sin.sin_family = AF_INET;
    sin.sin_port = htons(SERVER_PORT);
    sin.sin_addr.s_addr = htonl(INADDR_ANY);

	// Bind listening socket
    if(bind(lsd, (struct sockaddr *)&sin, sin_size) == -1)
    {
        printf("Cannot bind listening socket, program will exit!\n");
        exit(1);
    }
	// Listen for clients making connection requests
    if(listen(lsd, 5) == -1)
    {
        printf("Listen failed, program will exit!\n");
        exit(1);
    }
    // Accept connection request from client
    sd = accept(lsd, (struct sockaddr *)&sin, &sin_size);
    if (sd == -1)
    {
        printf("Cannot accept connect request from socket!\n");
        exit(1);
    }
    
    while(calcNum != 0) {
		read(sd, buffer, sizeof(buffer));
		sscanf(buffer,"%d %lf %d", &calcNum, &a, &N);
		bzero(buffer, sizeof(buffer));

		if(calcNum != 0)
		{
			printf("\nReceived data:\nChoice: %d\nNumber a: %f\nArray Size: %d\n", calcNum, a, N);

			read(sd, array, sizeof(array));
			for(i=0; i<N; i++)
			{
				printf("Array[%d]: %d\n",i, array[i]);
			}
		}
		switch(calcNum) 
		{
			case 1:
				for(i=0; i<N; i++)
					calcavg_1_arg.array[i] = array[i];
				calcavg_1_arg.N = N;

				result_1 = calcavg_1(&calcavg_1_arg, clnt);
				if (result_1 == (double *) NULL) {
					clnt_perror (clnt, "call failed");
				}
				sprintf(buffer,"Result from RPC Server: %f\n", *result_1);
				printf("\n%s\n", buffer);
				write(sd, buffer, sizeof(buffer));
				break;
			case 2:
				for(i=0; i<N; i++)
					calcmaxmin_1_arg.array[i] = array[i];
				calcmaxmin_1_arg.N = N;

				result_2 = calcmaxmin_1(&calcmaxmin_1_arg, clnt);
				if (result_2 == (returnData2 *) NULL) {
					clnt_perror (clnt, "call failed");
				}
				sprintf(buffer,"Result from RPC Server:\nMax: %d\nMin: %d\n", result_2->maxmin[0], result_2->maxmin[1]);
				printf("\n%s\n", buffer);
				write(sd, buffer, sizeof(buffer));
				break;
			case 3:
				for(i=0; i<N; i++)
					calcmult_1_arg.array[i] = array[i];
				calcmult_1_arg.N = N;
				calcmult_1_arg.a = a;

				result_3 = calcmult_1(&calcmult_1_arg, clnt);
				if (result_3 == (returnData3 *) NULL) {
					clnt_perror (clnt, "call failed");
				}
				printf("Result from RPC Server:\n");
				for(i=0; i<N; i++)
				{
					printf("Result[%d]: %f\n", i+1, result_3->returnArray[i]);
					resultArray[i] = result_3->returnArray[i];
				}
				write(sd, resultArray, sizeof(resultArray));
				break;
			default:
				printf("\nClient finished calculations, RPC client will exit.\n");
		}
   }
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	calc_prog_1 (host);
exit (0);
}
